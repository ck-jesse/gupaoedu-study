二叉查找树 （Binary Search Tree）

> 左子树的键值小于根的键值，右子树的键值大于根的键值。

平衡二叉查找树（AVL）

> 平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。

平衡多路查找树

> 



决定索引优劣的关键点：

1、索引的高度

2、磁盘IO次数



**B+Tree对比BTree的优点**

1、**磁盘读写代价更低**

一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，**那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。**

**2、查询速度更稳定**

由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。

带顺序索引的B+TREE

很多存储引擎在B+Tree的基础上进行了优化，**添加了指向相邻叶节点的指针**，形成了带有顺序访问指针的B+Tree，这样做是为了提高区间查找的效率，只要找到第一个值那么就可以顺序的查找后面的值。



**B-Tree**

![B-Tree](C:\Users\chuangkun\Pictures\B-Tree.png)



**B+Tree**

![B+Tree](C:\Users\chuangkun\Pictures\B+Tree.png)