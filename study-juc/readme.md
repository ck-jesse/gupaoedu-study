## 问题1：AQS是什么？
    分析：
    解答：
    1、AQS是 AbstractQueuedSynchronizer 的简称，他是一个队列同步器，被设计为一个基础同步器的框架；
    2、支持 共享锁模式 和 独占锁模式
    3、AQS本质上是一个双向链表队列，其中通过一个共享的同步状态、当前持有锁的线程来标记锁的状态、另外还含有 队列头部节点、尾部节点的字段，用来实现双向链表

## 问题2：ReentrantLock中公平锁和非公平锁的区别？
    分析：可通过源码来分析两者的区别
    解答：
    公平锁是按照AQS队列的顺序排队获取锁，
    非公平锁是直接通过CAS修改同步状态尝试获取锁，成功就返回，不成功则再按照AQS队列的顺序排队获取锁，从而达到不排队就直接抢占锁的目的。

## volatile 的原理

## synchronized 的原理
    基本点：比如同步代码块、同步普通方法、同步静态方法，以及他们的区别
    高级点：需要掌握 synchronized 的实现原理，比如对象头、synchronized 的锁优化、锁的膨胀过程。
    
    synchronized 同步锁一共具有四种状态：：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争情况逐渐升级，此过程为不可逆。
    所以 synchronized 锁膨胀过程其实就是无锁 → 偏向锁 → 轻量级锁 → 重量级锁的一个过程。

#### 偏向锁
    引入偏向锁的主要目的是：为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。
    其实在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁就可以减少很多不必要的性能开销和上下文切换。

#### 轻量级锁
    引入轻量级锁的主要目的是：在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
    需要注意的是轻量级锁并不是取代重量级锁，而是在大多数情况下同步块并不会出现严重的竞争情况，所以引入轻量级锁可以减少重量级锁对线程的阻塞带来的开销。
    
    所以偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，
    轻量级锁所以一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果超过指定自旋次数，则升级为重量级锁。

#### synchronized 的锁膨胀过程

![1563345531781](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345531781.png)

##### Java 对象头
    synchronized 用的锁是存储在 Java 对象头里的，下图是锁状态变化的情况，在分析 synchronized 锁升级需要对照这图：

![1563345512122](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345512122.png)    
    
##### 第一步：创建对象时，锁标志为无锁
    一个锁对象刚刚开始创建的时候，没有任何线程来访问它，它是可偏向的，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问他的时候，它会偏向这个线程。
    此时线程状态为无锁状态，锁标志位为 01，此时 Mark Word 如下图：

![1563345635610](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345635610.png)

##### 第二步：当第一个线程获A取锁时，锁标志为偏向锁
	当一个线程（线程 A）来获取锁的时，会首先检查所标志位，此时锁标志位为 01，然后检查是否为偏向锁，此时不为偏向锁，所以当前线程会修改对象头状态为偏向锁，
	同时将对象头中的 ThreadID 改成自己的 Thread ID，此时 Mark Word 如下图：

![1563345679767](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345679767.png)

##### 第三步：当第二个线程B获取锁时，通过 CAS 替换成功 Mark Word 中的 Thread ID，则锁标志为偏向锁
    如果再有一个线程（线程 B）过来，此时锁状态为偏向锁，该线程会检查 Mark Word 中记录的线程 ID 是否为自己的线程 ID，如果是，则获取偏向锁，执行同步代码块。
    如果不是，则利用 CAS 尝试替换 Mark Word 中的 Thread ID，成功，表示该线程（线程 B）获取偏向锁，执行同步代码块，此时 Mark Word 如下图：

![1563345707811](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345707811.png)

##### 第四步：当第二个线程B获取锁时，通过 CAS 替换失败 Mark Word 中的 Thread ID，则撤销偏向锁，锁标志升级为轻量级锁
    如果失败，则表明当前环境存在锁竞争情况，则执行偏向锁的撤销工作
    （**这里有一点需要注意的是：偏向锁的释放并不是主动，而是被动的，什么意思呢？就是说持有偏向锁的线程执行完同步代码后不会主动释放偏向锁，而是等待其他线程来竞争才会释放锁**）。
    撤销偏向锁的操作需要等到全局安全点才会执行，然后暂停持有偏向锁的线程，同时检查该线程的状态，如果该线程不处于活动状态或者已经退出同步代码块，则设置为无锁状态（线程 ID 为空，是否为偏向锁为 0 ，锁标志位为01）重新偏向，同时恢复该线程。
    若持有偏向锁的线程活着，则会遍历该线程栈帧中的锁记录，检查锁记录的使用情况，如果仍然需要持有偏向锁，则撤销偏向锁，升级为轻量级锁。


##### 第五步：在升级为轻量级锁之前，在原持有偏向锁的线程A的栈中创建一个锁记录，并将锁对象头中的 Mark Word 拷贝到该锁记录中（锁对象头中的锁记录指针指向线程A的锁记录地址），此时，线程A获得轻量级锁
    在升级为轻量级锁之前，持有偏向锁的线程（线程 A）是暂停的，
    JVM 首先会在原持有偏向锁的线程（线程 A）的栈中创建一个名为锁记录的空间（Lock Record），用于存放锁对象目前的 Mark Word 的拷贝，
    然后拷贝锁对象头中的 Mark Word 到原持有偏向锁的线程（线程 A）的锁记录中（官方称之为 Displaced Mark Word ），
    这时线程 A 获取轻量级锁，此时 Mark Word 的锁标志位为 00，指向锁记录的指针指向线程 A 的锁记录地址，如下图：

![1563345761715](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345761715.png)


##### 第六步：获得轻量级锁的线程A 执行同步代码块
    当原持有偏向锁的线程（线程 A）获取轻量级锁后，JVM 唤醒线程 A，线程 A 执行同步代码块，执行完成后，开始轻量级锁的释放过程。


##### 第七步：线程B在竞争获取锁时，通过自旋的方式来等待持有轻量级锁的线程释放锁，超过指定自旋次数，则升级为重量级锁
    对于其他线程而言，也会在栈帧中建立锁记录，存储锁对象目前的 Mark Word 的拷贝。
    JVM 利用 CAS 操作尝试将锁对象的 Mark Word 更新为指向当前线程的 Lock Record，如果成功，表明竞争到锁，则执行同步代码块，
    如果失败，那么线程尝试使用自旋的方式来等待持有轻量级锁的线程释放锁。
    当然，它不会一直自旋下去，因为自旋的过程也会消耗 CPU，而是自旋一定的次数，如果自旋了一定次数后还是失败，则升级为重量级锁，阻塞所有未获取锁的线程，等待释放锁后唤醒。


##### 第八步：释放轻量级锁，升级为重量级锁
	轻量级锁的释放，会使用 CAS 操作将锁对象头的 锁记录指针 Displaced Mark Word 替换为指向锁对象头自身的Mark Word，成功，则表示没有发生竞争，直接释放。
	如果失败，表明锁对象存在竞争关系，这时会轻量级锁会升级为重量级锁，然后释放锁，唤醒被挂起的线程，开始新一轮锁竞争，注意这个时候的锁是重量级锁。



## 基于TreeMap分析并理解红黑树结构

