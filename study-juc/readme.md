#### 为什么Java中 wait 方法需要在 synchronized 的方法中调用？
    它们是在有 synchronized 标记的方法或 synchronized 块中调用的，因为 wait 和 modify 需要监视对其上调用 wait 或 notify-get 的 Object。
    如果我们不从同步上下文中调用 wait() 或 notify() 方法，我们将在 Java 中收到 IllegalMonitorStateException。
    

## 问题1：AQS是什么？
    分析：
    解答：
    1、AQS是 AbstractQueuedSynchronizer 的简称，他是一个队列同步器，被设计为一个基础同步器的框架；
    2、支持 共享锁模式 和 独占锁模式
    3、AQS本质上是一个双向链表队列，其中通过一个共享的同步状态、当前持有锁的线程来标记锁的状态、另外还含有 队列头部节点、尾部节点的字段，用来实现双向链表
    http://ifeve.com/abstractqueuedsynchronizer-use/

## 问题2：ReentrantLock中公平锁和非公平锁的区别？
    分析：可通过源码来分析两者的区别
    解答：
    公平锁是按照AQS队列的顺序排队获取锁，
    非公平锁是直接通过CAS修改同步状态尝试获取锁，成功就返回，不成功则再按照AQS队列的顺序排队获取锁，从而达到不排队就直接抢占锁的目的。

## volatile 的原理
#### 操作系统语义
    计算机在运行程序时，每条指令都是在CPU中执行的，执行过程中势必会设计到数据的读写。
    我们知道程序运行的数据是存储在主存中的，此时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快。
    如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。
    CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。
    在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。
    举一个简单的例子：
    i++
    当线程运行这段代码时，首先会从主存中读取i(i = 1)，然后复制一份到CPU高速缓存中，然后CPU执行 + 1 （i = 2）操作，然后将数据（2）写入到告诉缓存中，最后刷新到主存中。
    这样做在单线程中是没有问题的，有问题的是在多线程中。
    假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？
    分析如下：
    两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，
    此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。
    解决缓存一致性方案有两种：
        通过在总线加LOCK#锁的方式：一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。
        通过缓存一致性协议（MESI协议）：它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。
    示例图：
    CPU --> 高速缓存Cache -->  |          |        | 
                              |缓存一致性 |        |
    CPU --> 高速缓存Cache -->  |   或者   |   -->  | 主存
                              |总线锁机制 |        |
    CPU --> 高速缓存Cache -->  |          |        |

#### Java 内存模型
    研究一下Java内存模型为我们提供了哪些保证以及在Java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。
    并发编程中我们一般都会遇到这三个基本概念：原子性、可见性、有序性。

##### 原子性
    原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
    volatile是无法保证复合操作的原子性

##### 可见性
    可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    Java提供了volatile来保证可见性。
    当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。 
    当然，synchronize和锁都可以保证可见性。

##### 有序性
    有序性：即程序执行的顺序按照代码的先后顺序执行。
    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。
    Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。

##### 剖析volatile原理
    volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。
    volatile可以保证线程保证可见性、不保证原子性，禁止指令重排序。
    在JVM底层volatile是采用“内存屏障”来实现的。
    
    在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：
    编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
    处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
    
##### happen-before原则
    happen-before原则保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。
    1、同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。
    2、监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）
    3、对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）
    4、线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）
    5、线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。
    6、如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。

    JVM是如何禁止重排序的？
    观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。
    lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。
    
    如何将class字节码转汇编代码？
    javap -c ReentrantTest.class
    
    总结：
    volatile看起来简单，但是要想理解它还是比较难的，这里只是对其进行基本的了解。
    volatile相对于synchronized稍微轻量些，在某些场合它可以替代synchronized，但是又不能完全取代synchronized，只有在某些场合才能够使用volatile。
    使用它必须满足如下两个条件：
    对变量的写操作不依赖当前值；
    该变量没有包含在具有其他变量的不变式中。
    volatile经常用于两个两个场景：状态标记两、double check
    如：懒汉式单例模式（双重检查锁），通过volatile禁止指令重排序，解决双重检查锁的问题。


## synchronized 的原理
    基本点：比如同步代码块、同步普通方法、同步静态方法，以及他们的区别
    高级点：需要掌握 synchronized 的实现原理，比如对象头、synchronized 的锁优化、锁的膨胀过程。
    
    synchronized 同步锁一共具有四种状态：：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争情况逐渐升级，此过程为不可逆。
    所以 synchronized 锁膨胀过程其实就是无锁 → 偏向锁 → 轻量级锁 → 重量级锁的一个过程。

#### 偏向锁
    引入偏向锁的主要目的是：为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。
    其实在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁就可以减少很多不必要的性能开销和上下文切换。

#### 轻量级锁
    引入轻量级锁的主要目的是：在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
    需要注意的是轻量级锁并不是取代重量级锁，而是在大多数情况下同步块并不会出现严重的竞争情况，所以引入轻量级锁可以减少重量级锁对线程的阻塞带来的开销。
    
    所以偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，
    轻量级锁所以一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果超过指定自旋次数，则升级为重量级锁。

#### java线程阻塞的代价
    java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，
    这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，
    用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。
    1、如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；
    2、如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。
    synchronized会导致竞争不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操作，被称为重量级锁，
    为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。
    注：明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。


#### synchronized 的锁膨胀过程

![1563345531781](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345531781.png)

##### Java 对象的结构
    Java对象 = 对象头（Header）+ 实例数据（Instance Data）+ 对齐填充（Padding）
    对象头：
        Mark Word：存储对象自身的运行时数据；
        类型指针：对象指向类的元数据的指针；（Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。）
        数组长度：只有数组对象才有（该数据在32位和64位JVM中长度都是32bit。）
        
        注意：Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
                25bit          4bit     1bit         2bit       =>  32bit
        无锁：   对象的HashCode， 分代年龄，是否偏向锁（0），锁标志（01）
        偏向锁：  线程ID，Epoch，  分代年龄，是否偏向锁（1），锁标志（01）
        轻量级锁：指向栈中锁记录的指针，锁标志（00）
        重量级锁：指向重量级锁的指针，锁标志（10）
        GC标记： 空，锁标志（11）

    实例数据：
        java代码中能看到的属性和他们的值就是实例数据。原生类型(primitive type)的内存占用如下：
        原生类型	   占用内存(bytes)
        boolean     1
        byte        1
        short       2
        char        2
        int         4
        float       4
        long        8
        double      8
        reference类型在32位系统上每个占用4bytes, 在64位系统上每个占用8bytes。
    对齐填充：
        JVM要求对象占的内存大小必须是8字节的整数倍，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
    synchronized 用的锁是存储在 Java 对象头里的，下图是锁状态变化的情况，在分析 synchronized 锁升级需要对照这图：

![1563345512122](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345512122.png)    
    
##### 第一步：创建对象时，锁标志为无锁
    一个锁对象刚刚开始创建的时候，没有任何线程来访问它，它是可偏向的，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问他的时候，它会偏向这个线程。
    此时线程状态为无锁状态，锁标志位为 01，此时 Mark Word 如下图：

![1563345635610](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345635610.png)

##### 第二步：当第一个线程获A取锁时，锁标志为偏向锁
	当一个线程（线程 A）来获取锁的时，会首先检查所标志位，此时锁标志位为 01，然后检查是否为偏向锁，此时不为偏向锁，所以当前线程会修改对象头状态为偏向锁，
	同时将对象头中的 ThreadID 改成自己的 Thread ID，此时 Mark Word 如下图：

![1563345679767](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345679767.png)

##### 第三步：当第二个线程B获取锁时，通过 CAS 替换成功 Mark Word 中的 Thread ID，则锁标志为偏向锁
    如果再有一个线程（线程 B）过来，此时锁状态为偏向锁，该线程会检查 Mark Word 中记录的线程 ID 是否为自己的线程 ID，如果是，则获取偏向锁，执行同步代码块。
    如果不是，则利用 CAS 尝试替换 Mark Word 中的 Thread ID，成功，表示该线程（线程 B）获取偏向锁，执行同步代码块，此时 Mark Word 如下图：

![1563345707811](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345707811.png)

##### 第四步：当第二个线程B获取锁时，通过 CAS 替换失败 Mark Word 中的 Thread ID，则撤销偏向锁，锁标志升级为轻量级锁
    如果失败，则表明当前环境存在锁竞争情况，则执行偏向锁的撤销工作
    （**这里有一点需要注意的是：偏向锁的释放并不是主动，而是被动的，什么意思呢？就是说持有偏向锁的线程执行完同步代码后不会主动释放偏向锁，而是等待其他线程来竞争才会释放锁**）。
    撤销偏向锁的操作需要等到全局安全点才会执行，然后暂停持有偏向锁的线程，同时检查该线程的状态，如果该线程不处于活动状态或者已经退出同步代码块，则设置为无锁状态（线程 ID 为空，是否为偏向锁为 0 ，锁标志位为01）重新偏向，同时恢复该线程。
    若持有偏向锁的线程活着，则会遍历该线程栈帧中的锁记录，检查锁记录的使用情况，如果仍然需要持有偏向锁，则撤销偏向锁，升级为轻量级锁。


##### 第五步：在升级为轻量级锁之前，在原持有偏向锁的线程A的栈中创建一个锁记录，并将锁对象头中的 Mark Word 拷贝到该锁记录中（锁对象头中的锁记录指针指向线程A的锁记录地址），此时，线程A获得轻量级锁
    在升级为轻量级锁之前，持有偏向锁的线程（线程 A）是暂停的，
    JVM 首先会在原持有偏向锁的线程（线程 A）的栈中创建一个名为锁记录的空间（Lock Record），用于存放锁对象目前的 Mark Word 的拷贝，
    然后拷贝锁对象头中的 Mark Word 到原持有偏向锁的线程（线程 A）的锁记录中（官方称之为 Displaced Mark Word ），
    这时线程 A 获取轻量级锁，此时 Mark Word 的锁标志位为 00，指向锁记录的指针指向线程 A 的锁记录地址，如下图：

![1563345761715](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563345761715.png)


##### 第六步：获得轻量级锁的线程A 执行同步代码块
    当原持有偏向锁的线程（线程 A）获取轻量级锁后，JVM 唤醒线程 A，线程 A 执行同步代码块，执行完成后，开始轻量级锁的释放过程。


##### 第七步：线程B在竞争获取锁时，通过自旋的方式来等待持有轻量级锁的线程释放锁，超过指定自旋次数，则升级为重量级锁
    对于其他线程而言，也会在栈帧中建立锁记录，存储锁对象目前的 Mark Word 的拷贝。
    JVM 利用 CAS 操作尝试将锁对象的 Mark Word 更新为指向当前线程的 Lock Record，如果成功，表明竞争到锁，则执行同步代码块，
    如果失败，那么线程尝试使用自旋的方式来等待持有轻量级锁的线程释放锁。
    当然，它不会一直自旋下去，因为自旋的过程也会消耗 CPU，而是自旋一定的次数，如果自旋了一定次数后还是失败，则升级为重量级锁，阻塞所有未获取锁的线程，等待释放锁后唤醒。


##### 第八步：释放轻量级锁，升级为重量级锁
	轻量级锁的释放，会使用 CAS 操作将锁对象头的 锁记录指针 Displaced Mark Word 替换为指向锁对象头自身的Mark Word，成功，则表示没有发生竞争，直接释放。
	如果失败，表明锁对象存在竞争关系，这时会轻量级锁会升级为重量级锁，然后释放锁，唤醒被挂起的线程，开始新一轮锁竞争，注意这个时候的锁是重量级锁。



## 基于TreeMap分析并理解红黑树结构

