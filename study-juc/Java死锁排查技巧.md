### 1、死锁
    死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，
    若无外力作用，这些进程（线程）都将无法向前推进。

### 2、死锁产生的原因
    1. 系统资源的竞争    
    系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。    
    2. 进程运行推进顺序不合适    
    进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。

### 3、死锁的四个必要条件
    【互斥条件】：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。    
    【请求与保持条件】：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。    
    【不可剥夺条件】:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。    
    【循环等待条件】: 若干进程间形成首尾相接循环等待资源的关系。    

### 4、处理死锁的方法
    预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
    避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
    检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。
    解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。
    
    预防死锁和避免死锁的区别： 
    预防死锁是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,
    而避免死锁则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。

### 5、避免死锁
    有序资源分配法
    
    【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。
    说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。


​    
### 6、死锁的排查
#### 方法一：使用 jps + jstack

1、在命令窗口，使用jps -l，查看java进程

![1563434766078](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434766078.png)

2、使用 jstack -l 12316

![1563434786046](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434786046.png)



#### 方法二：使用 jconsole

在window打开 JConsole，JConsole是一个图形化的监控工具！
1、在windons命令窗口 ，输出JConsole

![1563434803164](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434803164.png)

2、选择线程的tab

![1563434823300](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434823300.png)



#### 方法三：使用 Java Visual VM

在window打开 jvisualvm，jvisualvm是一个图形化的监控工具！
1、在windons命令窗口 ，输出 jvisualvm

![1563434856616](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434856616.png)



2、选择线程的tab

![1563434863286](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563434863286.png)