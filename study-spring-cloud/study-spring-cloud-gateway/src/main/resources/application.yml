server:
  port: 8081
spring:
  application:
    name: spring-cloud-gateway
  profiles:
    # 配置激活的路由配置
    active: after_route
  # 网关配置
  cloud:
    gateway:
      # 服务注册与发现配置
      discovery:
        locator:
          # true 表明gateway开启服务注册和发现的功能
          # 并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。
          enabled: true
          # true 将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了）
          # 比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。
          lower-case-service-id: true
      # 网关路由配置，可自定义路径并转发到具体的服务
      routes:
        - id: eureka-consumer-service
          # 服务的负载均衡地址
          uri: lb://EUREKA-CONSUMER-SERVICE
          # 断言配置，以/demo/**开头的请求都会转发到uri的地址上
          # TODO 怎么不起作用呢？
          predicates:
            - Path=/demo/**
          # 用StripPrefix的filter 在转发之前将/demo去掉
          # 同时将spring.cloud.gateway.discovery.locator.enabled改为false，如果不改的话，之前的localhost:8081/eureka-consumer-service/home这样的请求地址也能正常访问，因为这时为每个服务创建了2个router。
          filters:
            - StripPrefix=1


# 注册中心地址 - spring cloud gateway之服务注册与发现 - 配合服务注册中心进行路由转发
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8765/eureka/



# 三个横线表示在application.yml中再建一个配置文件
# 在此配置文件中通过spring.profiles来配置文件名，和spring.profiles.active保持一致，
# 然后配置spring cloud gateway 相关的配置，id标签配置的是router的id，每个router都需要一个唯一的id，uri配置的是将请求路由到哪里，
# Predict作为断言，它决定了请求会被路由到哪个router中。在断言之后，请求会被进入到filter过滤器的逻辑，

#After Route Predicate Factory
#配置一个时间，当请求的时间在配置时间之后，才交给 router去处理。否则则报错，不通过路由。
#如：http://localhost:8081 会路由到 http://httpbin.org:80/get
---
spring:
  cloud:
    gateway:
      # TODO 此处定义是否是全局限流器，待验证
      #redis-rate-limiter:
      #  replenishRate: 1
      #  burstCapacity: 3
      # routes 是一个集合，配置多个元素时，使用单个横线 "-" 来标记一个元素
      routes:
        - id: after_route
          uri: http://httpbin.org:80/get
          # 会被解析成PredicateDefinition对象 （name =After ，args= 2017-01-20T17:42:47.789-07:00[America/Denver]）
          # 在这里需要注意的是predicates的After这个配置，遵循的契约大于配置的思想，它实际被AfterRoutePredicateFactory这个类所处理，
          # 这个After就是指定了它的Gateway web handler类为AfterRoutePredicateFactory，同理，其他类型的predicate也遵循这个规则。
          predicates:
            # - After=2020-11-20T17:42:47.789-07:00[America/Denver]
            - After=2017-11-20T17:42:47.789-07:00[America/Denver]
          # RequestTime是一个自定义过滤器工厂的简写，对应到RequestTimeGatewayFilterFactory
          filters:
            # - RequestTime=true
            - name: RequestTime
              args:
                withParams: true
            - name: RequestRateLimiter
              args:
                # 用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。
                key-resolver: '#{@hostAddrKeyResolver}'
                # 当令牌不足时，返回 HttpStatus.TOO_MANY_REQUESTS(429, "Too Many Requests")
                # 令牌桶每秒填充平均速率
                redis-rate-limiter.replenishRate: 1
                # 令牌桶总容量
                redis-rate-limiter.burstCapacity: 1
  profiles: after_route
#Header Route Predicate Factory
#需要2个参数，一个是header名，另外一个header值，该值可以是一个正则表达式。当此断言匹配了请求的header名和值时，断言通过，进入到router的规则中去。
#如：curl -H 'X-Request-Id:1' localhost:8081
---
spring:
  cloud:
    gateway:
      routes:
        - id: header_route
          uri: http://httpbin.org:80/get
          predicates:
            - Header=X-Request-Id, \d+
  profiles: header_route
#Cookie Route Predicate Factory
#需要2个参数，一个时cookie名字，另一个时值，可以为正则表达式。它用于匹配请求中，带有该名称的cookie和cookie匹配正则表达式的请求。
#如：curl -H 'Cookie:name=forezp' localhost:8081
---
spring:
  cloud:
    gateway:
      routes:
        - id: cookie_route
          uri: http://httpbin.org:80/get
          predicates:
            - Cookie=name, forezp
  profiles: cookie_route

#Host Route Predicate Factory
#需要一个参数即hostname，它可以使用. * 等去匹配host。这个参数会匹配请求头中的host的值，一致，则请求正确转发。
#如：curl -H 'Host:www.fangzhipeng.com' localhost:8081
---
spring:
  cloud:
    gateway:
      routes:
        - id: host_route
          uri: http://httpbin.org:80/get
          predicates:
            - Host=**.fangzhipeng.com
  profiles: host_route
#Method Route Predicate Factory
#需要一个参数，即请求的类型。比如GET类型的请求都转发到此路由。
#如：curl localhost:8081
#如：curl -XPOST localhost:8081  则不会进入该路由
---
spring:
  cloud:
    gateway:
      routes:
        - id: method_route
          uri: http://httpbin.org:80/get
          predicates:
            - Method=GET
  profiles: method_route
#Path Route Predicate Factory
#需要一个参数: 一个spel表达式，应用匹配路径。
#如：curl localhost:8081/foo/dew
---
spring:
  cloud:
    gateway:
      routes:
        - id: path_route
          uri: http://httpbin.org:80/get
          predicates:
            - Path=/foo/{segment}
  profiles: path_route
#Query Route Predicate Factory
#配置了请求中含有参数foo，并且foo的值匹配ba.，则请求命中路由
#如：curl localhost:8081?foo=bar
---
spring:
  cloud:
    gateway:
      routes:
        - id: query_route
          uri: http://httpbin.org:80/get
          predicates:
            - Query=foo, ba.
  profiles: query_route