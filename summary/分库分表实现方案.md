# 概要

首先，我们来思考下面几个问题：

1、分库分表的常见方案有哪些？

> 常见的分库分表方案有 `范围法` 和 `哈希法` 。

2、基于什么维度来做分库分表？

> 分片键需要根据你的业务需求来确定。
>
> 比如，用户中心，一般将uid作为分片键；订单服务，一般将uid或mchid作为分片键；



# 分库分表方案

## 1、范围法 - range

范围法对分片键采用切分区间的方式，将数据水平切分到不同的数据库或表上去。

- 优点：

1）切分策略简单，根据分片键，按照范围，能够快速定位到数据在哪个库哪个表。

2）扩容简单，如果容量不够，只需增加数据库或表，扩展分片键的范围即可。

- 缺点：

1）分片键必须要满足递增的特性。

2）数据量不均匀，新增的库或表，在初期的数据会比较少。

3）请求量不均匀，一般来说，新下的订单查询活跃度会比较高，故后面的库比前面的库负载要高，导致服务器利用率不平衡。

## 2、哈希法 - hash

哈希法对分片键采用hash的方式，将数据水平切分到不同的数据库或表上去。hash简单理解就是取模。

- 优点：

1）切分策略简单，根据分片键，按照hash，能够快速定位到数据在哪个库哪个表。

2）数据量均衡，根据分片键，数据在各个库上的分布是均衡的。

3）请求量均衡，根据分片键，负载到各个库上的分布是均衡的。

- 缺点：

1）扩容麻烦，如果容量不够，需要增加一个库或表，重新hash会导致数据迁移。



实施水平切分之后，会带来什么新的问题呢？

以订单服务为例，使用uid进行水平切分之后，对基于uid属性的查询，可以直接路由到库，但对于非uid属性的查询，就悲剧了，由于不知道数据落在哪个库上，往往需要遍历所有库和表，性能会显著下降。

在进行讨论前，先来对业务进行简要分析，订单服务非uid属性的查询，有如下两类典型业务需求：

1、用户侧：前台访问

> 根据uid查询订单列表；根据订单ID查询订单。
>
> 用户侧的查询，访问量较大，服务需要高可用，并且对一致性要求较高。

2、运营侧：后台访问

> 通过订单ID、用户ID、商家ID、交易时间等维度来进行查询。
>
> 运营侧的查询，基本上是分页查询，访问量低，对可用性和一致性要求不高。



针对这两类不同的业务需求，应该使用什么样的方案来解决呢？

总的来说，核心思路如下：

1、用户侧：采用`“建立非uid属性到uid的映射关系”`的架构方案；

2、运营侧：采用“前台与后台分离”的架构方案；

## 用户侧，如何实施呢？

常见方法如下：

**1）映射法：**

- 思路：

uid能直接定位到库，订单ID不能直接定位到库，如果通过订单ID能查询到uid，便可解决该问题。

- 具体方案：

1）建立订单ID和uid的映射关系表；

2）用订单ID来查询时，先通过映射关系表查询到uid，再通过uid定位到对应的库；

3）把映射关系存放在缓存中，提高性能

4）映射关系表属性较少，可以容纳非常多数据，一般不需要分库；

5）如果数据量过大，可以通过订单ID来分库；

- 缺点：

数据访问时，多一次网络交互，即一次cache查询。

> 思考：是否可以结合本地缓存来实现呢？若可以又会带来什么新的问题呢？

**2）业务因子法：**

思路：

从uid中抽取`业务因子`，融入到订单ID中。假设分16库，采用uid%16进行路由，uid的最后3bit决定这条数据落在哪个库上，这3bit就是所谓的`业务因子`。

具体方案：

1）在用户下单时，根据特定函数基于uid生成3bit业务因子；

2）生成全局唯一的订单ID；

3）将3bit业务因子拼接到订单ID末尾，生成最终的订单ID；

4）按照3bit业务因子来路由到对应的库进行数据插入；

5）用订单ID来访问时，先通过特定函数从订单ID中获取到3bit业务因子，再直接定位到库进行操作。

缺点：

数据可能分布不均。

> 思考：若生成的商户ID、用户ID、订单ID具有相同的业务因子，数据的分布是什么情况呢？是否可以在一定程度上解决运营侧的业务需求呢？



## 运营侧，如何实施呢？

为了满足后台业务各类“奇形怪状”的需求，往往会在数据库上建立各种索引，这些索引占用大量内存，会使得用户侧前台业务uid/订单ID/商户ID上的查询性能与写入性能大幅度降低，处理时间增长。











订单服务，是所有电商平台中必备的子系统。随着业务发展，订单的数据量不断增加，吞吐量不断增大，订单服务的架构要继续演进，必然需要对数据库进行水平切分。

一般订单有两类典型的业务需求：

1、用户侧：前台访问

> 最典型的是基于用户ID查询订单信息，基本上是单条记录查询，访问量较大。

2、商家侧：后台访问

> 最典型的是基于商户ID查询订单信息，基本上是分页查询，访问量较低。

对于这两类业务需求，我们可以分别基于用户ID和商家ID作为分片键来做分库分表，这种方式冗余了一份订单数据，这样商家侧查询订单列表时无需做聚合汇总操作，查询效率更高，也就是说用空间来换时间。

那么是否可以不冗余商家侧的这一份订单数据，同时又达到查询订单列表的高效呢？

下面提供一种实战方案：

1、基于商家ID生成一个业务因子A

2、生成用户ID时，将该业务因子A作为用户ID的一部分

3、生成订单ID时，将该业务因子A作为订单ID的一部分

4、将业务因子A作为分片键来进行分库分表

经过上面4个步骤，达到同一个商家下用户的订单落到相同的库和表上，这样一份订单数据，就可以支持到商家/用户/订单三个维度的查询场景。不过这个方案存在一个缺陷：数据分布不均匀，商家体量大的数据对应就多。





