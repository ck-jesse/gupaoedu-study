
# 高并发的优化手段
## 架构层面
1、服务化
> 按业务或功能拆分服务

2、数据库
> 分库分表，读写分离

3、存储
> Redis，ES支撑复杂查询
>
4、服务无状态化设计
> 便于水平扩展,自动扩缩容
>
5、缓存
> 本地缓存，分布式缓存，二级缓存，DNS缓存，浏览器缓存等。
>
> 应对热点数据、秒杀、静态页面等场景。
> 
6、容量规划
> 单机瓶颈，PV(Page View)，UV(User View)
>
> 单接口压测 / 链路压测
>
> 压测 -> 关注指标（QPS/CPU/内存） -> 容量规划 -> 机器数量（扩缩容）
>> 注：压测一定要有目标
>
7、异步化
> 消息队列，异步解耦，流量削峰。
>
8、冗余
> 分区副本，如kafka中partition的多副本机制。
>

## 代码层面
> 1、DB层面，SQL优化，索引优化
>
> 2、异步化，线程池的使用
>
> 3、池化技术，线程池，连接池
>
> 4、内存是有的优化，弱引用、软引用、强引用
>
> 5、事务大小
>
> 6、缓存，本地缓存+分布式缓存
> 
> 7、调用链路优化，减少不必要的调用。
>
> 8、容错
>
> 9、限流
>
> 10、复杂业务的重构，使其便于扩展，便于维护。
>
> 11、对异常的考量，在代码上形成闭环，使业务更加完备。如支付请求超时，自动重试或自动退款
>
>

优化准则
1、避免为了性能牺牲代码的可读性。
2、不要独立地看待性能。衡量与带来的收益相比所需投入的工作量。
3、程序的大小很重要。性能优化通常只对运行了长时间的大型项目有价值。性能通常不是小项目的关注点。
4、运行起来程序比一心钻研它的性能具有更高的优先级。一旦你已经有了可工作的程序，如有必要的话，你可以使用剖析器提高它的效率。只有当性能是关键因素时，才需要在设计/开发阶段考虑性能。
5、不要猜测瓶颈发生在哪。运行剖析器，让剖析器告诉你。
6、无论何时有可能的话，显式地设置实例为 null 表明你不再用它。这对垃圾收集器来说是个有用的暗示。
7、static final 修饰的变量会被 JVM 优化从而提高程序的运行速度。因而程序中的常量应该声明 static final。



## 负载均衡
负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。


二层负载
> 基于mac地址
>
三层负载
> IP层
>
四层负载
> IP+Port, F5/LVS/Nginx
> 
> 硬负载
> 
> F5,第四层交换功能就象是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。
>
> 软负载
>
> 软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的鲁棒性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满足多种应用需求，这对于分布式的系统来说必不可少。
>
七层负载
> http协议(URI) / 应用层负载
>
> 网关 通过URI来分发请求；Robbin 应用层负载。