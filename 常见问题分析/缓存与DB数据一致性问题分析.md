# DB 与 缓存 间数据不一致问题分析：

## 常见缓存架构的方案

### 写操作的顺序

> （1）淘汰cache
>
> （2）写数据库



### 读操作的顺序

> （1）读cache，如果cache hit则返回；
>
> （2）如果cache miss，则读从库（也可能是主库）；
>
> （3）读从库后，将数据放回cache；



### 数据不一致问题

#### 分析

在一些异常时序情况下，有可能存在数据不一致的问题，如下：

> （1）主库数据还没有同步到从库时，从从库读取到旧数据放入cache
>
> （2）写操作过程中，在 淘汰cache 和 写数据库 操作之间，有请求从主库读取旧数据放入cache



#### 解决方案

`解决办法是“缓存双淘汰”`，写操作时序升级为：

> （1）淘汰cache；
>
> （2）写数据库；
>
> （3）在经过 “主从同步延时窗口时间” 后，再次发起一个 异步淘汰cache 的请求；

这样，即使有脏数据入cache，一个小的时间窗口之后，脏数据还是会被淘汰。带来的代价是，多引入一次读miss（成本可以忽略）。

除此之外，最佳实践之一是：**建议为所有cache中的item设置一个超时时间**。









