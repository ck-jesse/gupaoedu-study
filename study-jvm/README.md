# study-jvm

### JVM 日志输出参数
     -XX:+PrintGC 输出GC日志
     -XX:+PrintGCDetails 输出GC的详细日志
     -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
     -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
     -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
     -Xloggc:../logs/gc.log 日志文件的输出路径

### JAVA内存区域

![1563246375290](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563246375290.png)



### 什么是GC ROOT？

    一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，
    当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。



### 哪些对象是GC ROOT？

    虚拟机栈（栈帧中的本地变量表）中引用的对象
    方法区中类静态属性引用的对象
    方法区中常量引用的对象
    本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

### GC 垃圾回收
    Garbage Collection，释放垃圾占用的空间，防止内存泄露。

### GC 算法
#### 1、标记 --- 清除算法

![1563246295777](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563246295777.png)

    标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，
    哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。
    缺点：
    回收以后，内存会被切成很多段（内存碎片），而我们开辟空间时需要的是连续的内存区域，这样就导致，我们本身还要很多内存，但却使用不了。

#### 2、复制算法

![1563246276854](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563246276854.png)

    复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。
    它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
    当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。
    缺点：
    只能使用一半的内存，代价太大。

#### 3、标记整理算法

![1563246257478](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563246257478.png)

    标记整理算法（Mark-Compact）标记过程仍然与标记 --- 清除算法一样，但后续步骤不是直接对可回收对象进行清理，
    而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。
    标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。
    看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。

#### 4、分代收集算法
    分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，
    而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。
    一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
    而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 --- 整理算法来进行回收。

### 内存模型与回收策略
    Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域。
    Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。

![1563246202672](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1563246202672.png)



#### 1、Eden 区

    IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，
    当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。
    通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，
    将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

#### 2、Survivor 区
    Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。
    Survivor 又分为2个区，一个是 From 区，一个是 To 区。
    每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。

#### 3、Old 区
    老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。
    内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。
    由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 --- 整理算法。

#### 4、那些对象会进入Old 区
    【大对象】
    大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。
    这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。
    
    【长期存活对象】
    虚拟机给每个对象定义了一个对象年龄（Age）计数器。
    正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。
    当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。
    
    【动态对象年龄】
    虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。
    这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。
